use crate::error::GeminiError;
use crate::types::*;
use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::sync::Arc;
use tokio::net::TcpStream;
use tokio::sync::Mutex as TokioMutex;
use tokio_tungstenite::{MaybeTlsStream, WebSocketStream, tungstenite::protocol::Message}; // Added Serialize, Deserialize

// Enum to identify the provider
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ApiProvider {
    Gemini,
    OpenAi,
}

// Unified representation of server events
#[derive(Debug, Clone)]
pub enum UnifiedServerEvent {
    SetupComplete,
    ContentUpdate {
        text: Option<String>,
        audio: Option<Vec<i16>>, // Decoded audio samples
        done: bool,              // Is this the final part of the *current* content (text/audio)?
    },
    TranscriptionUpdate {
        text: String,
        done: bool,
    },
    ToolCall {
        id: Option<String>, // Call ID needed for response
        name: String,
        args: Value,
    },
    ModelTurnComplete,       // Model finished its current turn/response
    ModelGenerationComplete, // Model finished all generation for the request
    UsageMetadata(UsageMetadata),
    Error(ApiError),
    ProviderSpecific(Value), // For unhandled/specific events
    Close,                   // Server closed connection
}

#[derive(Debug, Clone, Serialize, Deserialize)] // Added Serialize/Deserialize
pub struct ApiError {
    pub code: String,
    pub message: String,
    pub event_id: Option<String>, // Correlates to client event_id if provided
}

// Alias for the WebSocket sink
pub type WsSink =
    futures_util::stream::SplitSink<WebSocketStream<MaybeTlsStream<TcpStream>>, Message>;

// Define a trait for the application state
pub trait AppState: Send + Sync + 'static {
    // Marker trait, potentially add 'Any' bound if downcasting is needed everywhere
    // use std::any::Any;
    // fn as_any(&self) -> &dyn Any;
}
// Blanket implementation for any S that meets the bounds
impl<S: Send + Sync + 'static> AppState for S {
    // fn as_any(&self) -> &dyn Any { self }
}

// Common configuration needed by backends
#[derive(Clone, Debug, Default)]
pub struct BackendConfig {
    pub model: String,
    pub system_instruction: Option<Content>, // Keep Content struct for now
    pub generation_config: Option<GenerationConfig>,
    pub tools: Vec<ToolDefinition>, // Unified tool definition
    pub realtime_input_config: Option<RealtimeInputConfig>, // Primarily Gemini?
    pub output_audio_transcription: Option<AudioTranscriptionConfig>,

    // OpenAI specific (or potentially others)
    pub voice: Option<String>,                  // e.g., "alloy"
    pub input_audio_format: Option<String>,     // e.g., "pcm16", "g711_ulaw"
    pub output_audio_format: Option<String>,    // e.g., "pcm16"
    pub transcription_model: Option<String>,    // e.g., "gpt-4o-transcribe"
    pub transcription_language: Option<String>, // e.g., "en"
    pub transcription_prompt: Option<String>,
    pub include_logprobs: bool, // For OpenAI transcription
}

// Unified Tool Definition (used by builder and backend)
#[derive(Clone, Debug)]
pub struct ToolDefinition {
    pub name: String,
    pub gemini_declaration: FunctionDeclaration, // Generated by macro
    pub openai_definition: Value,                // Generated by macro as JSON value
}

// The core backend trait
#[async_trait]
pub trait LiveApiBackend: Send + Sync + 'static {
    fn provider_type(&self) -> ApiProvider;

    // --- Connection ---
    fn get_websocket_url(&self, api_key: &str) -> Result<url::Url, GeminiError>;
    fn configure_websocket_request(
        &self,
        api_key: &str,
        request: http::Request<()>,
        config: &BackendConfig, // Config needed for model param etc.
    ) -> Result<http::Request<()>, GeminiError>; // Return Result
    async fn get_initial_messages(
        &self,
        config: &BackendConfig,
    ) -> Result<Vec<String>, GeminiError>;

    // --- Message Building (Client -> Server) ---
    fn build_session_update_message(&self, config: &BackendConfig) -> Result<String, GeminiError>;
    fn build_text_turn_message(
        &self,
        text: String,
        // end_of_turn: bool, // May not be applicable to all
    ) -> Result<String, GeminiError>;
    fn build_audio_chunk_message(
        &self,
        audio_samples: &[i16],
        sample_rate: u32,       // Sample rate might be needed by backend
        config: &BackendConfig, // For format info
    ) -> Result<String, GeminiError>;
    fn build_audio_stream_end_message(&self) -> Result<String, GeminiError>;
    fn build_tool_response_message(
        &self,
        responses: Vec<FunctionResponse>, // Use unified FunctionResponse struct
    ) -> Result<String, GeminiError>;
    // Add methods for other actions if needed (e.g., activity start/end)
    fn build_request_response_message(&self) -> Result<String, GeminiError>; // For OpenAI explicit trigger

    // --- Message Parsing (Server -> Client) ---
    async fn parse_server_message(
        &self,
        message: Message,
        handlers: &Arc<Handlers<dyn AppState + Send + Sync>>,
        state: &Arc<dyn AppState + Send + Sync>,
        ws_sink: &Arc<TokioMutex<WsSink>>,
        output_audio_format: &Option<String>, // Needed for decoding audio
    ) -> Result<Vec<UnifiedServerEvent>, GeminiError>;
}
